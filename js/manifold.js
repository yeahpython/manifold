/* 
.-------------.
| manifold.js |
'-------------'
A free javascript library built on THREE.js (and jQuery??) that makes it 
easier to create demos of linear algebra and multivariable calculus.

The latest version of this project may be found at github.com/yeahpython/manifold

*/


/*

What's up with updateRules? I guess this thing builds a dependency graph of all 
objects in the scene so that we don't have to regenerate all the functions every time.

typical patterns:
Surface transported from a template and controlled using a cursor.
Surface generated by applying a function to a previous surface under a function.
Preimage of a point under a linear map. Preimage depends on point and map.
Column vectors computed from the Jacobian of a function at a point multiplied by a previous set of vectors.
*/


(function(manifold, $, THREE, undefined){
	
	// Public Methods
	/*
	manifold.board
	--------------
	Makes a board (secretly a THREE.js scene, camera and renderer).
	   
	Parameters:
	       id: a string indicating the DOM element where we want to put the board
	    width: width in pixels of the board
	   height: height in pixels of the board
	*/
	manifold.board = function(id, width, height) {
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 75, width / height, 0.1, 1000 );

		// fastest
		//var renderer = new THREE.WebGLRenderer();

		// fast
		var renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});

		renderer.setClearColor(0xffffff, 1.0);

		// slower, with rounded line caps
		//var renderer = new THREE.CanvasRenderer({alpha:true, antialias:true});

		renderer.setSize( width, height );
		var box = document.getElementById(id);
		box.appendChild( renderer.domElement );
		var board = {
			scene:scene,
			camera:camera,
			renderer:renderer
		}
		boards.push(board);
		return board;
	}

	// Adds an object representing three-dimensional space to the board.
	// Adds axes by default, although this may change.
	manifold.space3 = function(board, origin) {
		return space(3, board, origin);
	}

	// Returns an approximate Jacobian of function userFunc
	// so if userfunc takes an n-vector and returns a m-vector,
	// this takes an n-vector and returns an m by n matrix
	manifold.approximateJacobian = function(userFunc, epsilon) {
		// assuming 3x3 for now.
		return function(input) {
			col1 = userFunc(new THREE.Vector3(epsilon, 0, 0).add(input)).sub(userFunc(input)).divideScalar(epsilon);
			col2 = userFunc(new THREE.Vector3(0, epsilon, 0).add(input)).sub(userFunc(input)).divideScalar(epsilon);
			col3 = userFunc(new THREE.Vector3(0,0, epsilon).add(input)).sub(userFunc(input)).divideScalar(epsilon);
			//document.getElementById("debug").innerHTML = col1.x;
			return new THREE.Matrix3().set(col1.x, col2.x, col3.x,
				                 col1.y, col2.y, col3.y,
				                 col1.z, col2.z, col3.z);
		};
	}

	manifold.transformBasisWithJacobian = function(basis, scene, space, oldSpace, jacobian) {
		var newBasis = manifold.unitBasis(3, scene, space);
		for (var i = 0; i < basis.children.length; i++) {
			newBasis.children[i].geometry.dynamic = true;
		}
		updateRules.push({
			update:function(){
				var m = jacobian(cursor);
				for (var i = 0; i < basis.children.length; i++) {
					newBasis.children[i].geometry.vertices[1].copy(basis.children[i].geometry.vertices[1]);
					newBasis.children[i].geometry.vertices[1].applyMatrix3(m);
					newBasis.children[i].geometry.verticesNeedUpdate = true;
				}
			}
		});
		return newBasis;
	}

	// Make a new surface in a given space
	manifold.surface = function(type, space, board) {
		if (type == "cube") {
			// make a cube that moves around in the space according to user input
			var mesh = new THREE.Mesh(cursorSurface.clone(), paper);
			board.scene.add(mesh);
			THREE.SceneUtils.attach(mesh, board.scene, space);
			space.updateMatrixWorld();
			mesh.position.set(0,0,0);
			return mesh;
		} else {
			throw "Unrecognized surface type";
		}
	}

	// Create the image of object under userFunc in space
	// currently compatible with the following objects:
	//
	manifold.image = function(userFunc, object, space, board) {
		var mesh = new THREE.Mesh(object.geometry.clone(), paper);
		board.scene.add(mesh);
		THREE.SceneUtils.attach(mesh, board.scene, space);
		space.updateMatrixWorld();
		mesh.position.set(0,0,0);
		mesh.geometry.dynamic = true;
		updateRules.push({
			update:function(){
				for (var i = 0; i < object.geometry.vertices.length; i++) {
					mesh.geometry.vertices[i] = userFunc(object.geometry.vertices[i]);
				}
				mesh.geometry.verticesNeedUpdate = true;
			}
		});
		return mesh;
	}

	var xAxisMaterial = new THREE.LineBasicMaterial({
		color: 0xff0000,
		linewidth: 10,
		linecap:'round'
	});

	var yAxisMaterial = new THREE.LineBasicMaterial({
		color: 0x00ff00,
		linewidth: 10
	});

	var zAxisMaterial = new THREE.LineBasicMaterial({
		color: 0x0000ff,
		linewidth: 10
	});

	manifold.translateBasisWithFunction = function(basis, scene, space, userFunc) {
		var basisCopy = basis.clone();// manifold.unitBasis(3, scene, space);
		basisCopy.position = new THREE.Vector3();
		scene.add(basisCopy);
		THREE.SceneUtils.attach(basisCopy, scene, space);

		updateRules.push({
			update:function(){
				basisCopy.position.copy(userFunc(cursor));
			}
		});
		return basisCopy;

	}

	manifold.unitBasis = function(dimensions, scene, space) {
		if (dimensions != 3) {
			throw "Not dealing with less than three dimensions at the moment";
		}

		var basis = new THREE.Object3D();

		var xUnit = new THREE.Geometry();
		xUnit.vertices.push(
			new THREE.Vector3( 0, 0, 0 ),
			new THREE.Vector3( 5, 0, 0 )
		);
		var i = new THREE.Line( xUnit, xAxisMaterial, THREE.LinePieces);

		var yUnit = new THREE.Geometry();
		yUnit.vertices.push(
			new THREE.Vector3( 0, 0, 0 ),
			new THREE.Vector3( 0, 5, 0 )
		);
		var j = new THREE.Line( yUnit, yAxisMaterial, THREE.LinePieces);

		var zUnit = new THREE.Geometry();
		zUnit.vertices.push(
			new THREE.Vector3( 0, 0, 0 ),
			new THREE.Vector3( 0, 0, 5 )
		);
		var k = new THREE.Line( zUnit, zAxisMaterial, THREE.LinePieces);

		scene.add(basis);
		scene.add(i);
		scene.add(j);
		scene.add(k);

		THREE.SceneUtils.attach(i, scene, basis);
		THREE.SceneUtils.attach(j, scene, basis);
		THREE.SceneUtils.attach(k, scene, basis);
		THREE.SceneUtils.attach(basis, scene, space);

		//basis.updateMatrixWorld();
		basis.position.set(0,0,0);
		return basis;
	}

	// draws a line between two spaces, with text showing label over it.
	manifold.arrow = function(source, target, label) {

	}

	manifold.render = function() {

		// lazy (as a programmer) solution for turning off animations.
		// frames keep on going but I don't do anythin about it.
		if (manifold.animating) {
			updateAll();
			var inputX = (mouse.x / $(window).width()) - 0.5;
			var inputY = (mouse.y / $(window).height()) - 0.5;
			for (var i = 0; i < boards.length; i++) {
				boards[i].renderer.render(boards[i].scene, boards[i].camera);
				var cameraTarget = new THREE.Vector3(20 *inputX,20 * inputY, 30 );
				boards[i].camera.position.lerp(cameraTarget, 0.01);
				boards[i].camera.lookAt(new THREE.Vector3(0,0,0));
			}
		}
		requestAnimationFrame(manifold.render);
	}

	function updateAll() {
		// future: sort according to dependencies
		// future: find redundant updates.
		for (var i = 0; i < updateRules.length; i++) {
			updateRules[i].update();
		}
	}

	/*
	function updateAll() {
		// The right thing to do is to do a topological sort of everything based on dependencies and do them in order.
		// I'm probably not going to do that...
		updateIteration++;
		var l = boards.length;
		for (var i = 0; i < l; i++) {
			enforceUpdate(boards[i].scene);
		}
	}

	function enforceUpdate(object) {
		// recurse through the children, updating everything!

		// Right now, everything is tree-shaped, so updateIteration doesn't really matter.

		// if it doesn't have an updateRule, give it one. Its children might have updateRules.
		if (object.updateRule == undefined) {
			object.updateRule = {};
		}

		if (object.updateRule.lastUpdate == updateIteration) {
			return;
		}

		if (object.updateRule.lastSearch == updateIteration) {
			// We've really screwed up, and there's a cyclic dependency.
			throw "Error: Cyclic dependency detected";
		}

		object.updateRule.lastSearch = updateIteration;

		for (var i = 0; i < object.children.length; i++) {
			enforceUpdate(object.children[i]);
		}

		if (object.updateRule.position != undefined) {
			inputX = (mouse.x / $(window).width()) - 0.5;
			inputY = (mouse.y / $(window).height()) - 0.5;
			updateMeshWithInput(object, new THREE.Vector3( 10*inputX , -10 * inputY, 0) );
		}

		if (object.updateRule.surface != undefined) {

		}

		object.updateRule.lastUpdate = updateIteration;
	}*/

	// This thing looks like it's going to become a huge series of things that depend on each other.
	// I want to make it automatic, so that the user can just declare what depends on what, and have
	// everything work out visually.

	// I also want it to be modular, because I don't know what exactly depends on what.

	// I also need this thing to know when something doesn't need to be changed.

	// I don't want to build too much infrastructure outside of THREE.js, but I don't want to 
	// simply hack into the existing THREE.js structure either.
	var updateRules = [
	{
		update:function() {
			get3DCursor();
		}
	}];

	manifold.controlSurfacePositionWithCursor = function(surface) {
		updateRules.push(
			{
				update :
				function()
				{
					updateMeshWithInput(surface, cursor);
				}
			}
		);
	}

	var cursorControl = "mouse";

	var cursor = new THREE.Vector3(0,0,0);
	var leapCursor3d = new THREE.Vector3(0,0,0);

	manifold.tryToControlInputWithLeap = function() {
		cursorControl = "leap";
		Leap.loop(function (frame) {
		    if (frame.hands.length) {
		    	p = frame.hands[0].palmPosition;
				leapCursor3d.set(p[0], -p[2], p[1] - 50).divideScalar(40);
			}
		});
	}


	function get3DCursor(){
		if (cursorControl == "leap") {
			cursor.copy(leapCursor3d);
		} else {
			cursor.copy(mouse3d);
		}
	}

	/*manifold.controlSurfacePositionWithCursor = function(surface) {
		// Rig things up so that every time we need to compute geometry of this surface,
		// we use the mouseInput
		if (surface.updateRule == undefined) {
			surface.updateRule = {};
		}
		surface.updateRule.position = function() {
			inputX = (mouse.x / $(window).width()) - 0.5;
			inputY = (mouse.y / $(window).height()) - 0.5;
			updateMeshWithInput(surface.mesh, new THREE.Vector3( -10*inputX , 10 * inputX, -10 * inputY) );
		};
	}*/

	function updateMeshWithInput(mesh, vec) {
		mesh.geometry.dynamic = true;
		if (mesh.geometry.vertices.length == cursorSurface.vertices.length) {
			for (var i = 0; i < cursorSurface.vertices.length; i++) {
				mesh.geometry.vertices[i].copy(cursorSurface.vertices[i]).add(vec);
			}
		} else {
			throw "Error: Mesh has incorrect length";
		}
		mesh.geometry.verticesNeedUpdate = true;
	}


	var updateIteration = 0;

	var boards = [];


	// load a texture, set wrap mode to repeat
	var texture = THREE.ImageUtils.loadTexture( "texture.png" );
	texture.wrapS = THREE.RepeatWrapping;
	texture.wrapT = THREE.RepeatWrapping;
	texture.repeat.set( 30, 30 );

	//var paper = new THREE.MeshLambertMaterial({color:0xffffff});
	//var paper = new THREE.MeshBasicMaterial({color:0xffffff, map:texture, transparent:true});
	var paper = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.1});
	//var paper = new THREE.MeshLambertMaterial({color:0xffffff, wireframe:true});


	var linematerial = new THREE.LineBasicMaterial({
		color: 0x222222,
		linewidth: 1
	});

	var cursorSurface = new THREE.SphereGeometry(6,100,100);
	var min = new THREE.Vector3(-1,-1,-1);
	var max = new THREE.Vector3(1,1,1);
	for (var i = 0; i < cursorSurface.vertices.length; i++) {
		cursorSurface.vertices[i] = cursorSurface.vertices[i].clamp(min,max);
	}

	var mouse = {x: 0, y: 0};
	var mouse3d = new THREE.Vector3(0,0,0);

	document.addEventListener('mousemove', function(e){ 
	    mouse.x = e.clientX || e.pageX; 
	    mouse.y = e.clientY || e.pageY;
	    var inputX = (mouse.x / $(window).width()) - 0.5;
		var inputY = (mouse.y / $(window).height()) - 0.5;
		mouse3d.set( 10*inputX , -10 * inputY, 0);
	}, false);


	manifold.animating = true;

	// Private Methods

	/*

	manifold.space
	--------------
	Makes a space (Secretly a glorified THREE.Object3D)
	gives the space axes
	puts the space in board at the given origin

	*/
	function space(dimension, board, origin) {
		if (dimension != 3) {
			throw "Dimensions other than 3 not supported";
		}
		var plot = new THREE.Object3D();
		var axes = new THREE.Geometry();
		/*axes.vertices.push(
			new THREE.Vector3( -10, 0, 0 ),
			new THREE.Vector3( 10, 0, 0 ),
			new THREE.Vector3( 0, -10, 0 ),
			new THREE.Vector3( 0, 10, 0 ),
			new THREE.Vector3( 0, 0, -10 ),
			new THREE.Vector3( 0, 0, 10 )
		);
		var line = new THREE.Line( axes, linematerial, THREE.LinePieces);
		*/

		axes.vertices.push(
			//triple
			new THREE.Vector3( -10, -10, -10 ),
			new THREE.Vector3( 10, -10, -10 ),

			new THREE.Vector3( -10, -10, -10 ),
			new THREE.Vector3( -10, 10, -10 ),
			new THREE.Vector3( -10, -10, -10 ),
			new THREE.Vector3( -10, -10, 10 ),

			// L-shape
			new THREE.Vector3( 10, -10, -10 ),
			new THREE.Vector3( 10, 10, -10 ),

			new THREE.Vector3( 10, -10, -10 ),
			new THREE.Vector3( 10, -10, 10 ),

			// L-shape
			new THREE.Vector3( -10, 10, -10 ),
			new THREE.Vector3( 10, 10, -10 ),

			new THREE.Vector3( -10, 10, -10 ),
			new THREE.Vector3( -10, 10, 10 ),

			// L-shape
			new THREE.Vector3( -10, -10, 10 ),
			new THREE.Vector3( 10, -10, 10 ),

			new THREE.Vector3( -10, -10, 10 ),
			new THREE.Vector3( -10, 10, 10 ),

			// triple
			new THREE.Vector3( -10, 10, 10 ),
			new THREE.Vector3( 10, 10, 10 ),

			new THREE.Vector3( 10, -10, 10 ),
			new THREE.Vector3( 10, 10, 10 ),

			new THREE.Vector3( 10, 10, -10 ),
			new THREE.Vector3( 10, 10, 10 )



		);
		var line = new THREE.Line( axes, linematerial, THREE.LinePieces);

		board.scene.add( line );
		board.scene.add( plot );
		THREE.SceneUtils.attach(line, board.scene, plot);

		plot.position.add(origin);
		plot.axes = line;
		return plot;
	}


}(window.manifold = window.manifold || {}, jQuery, THREE));